import { compareTwoSnapshots } from "../compareTwoSnapshots.js"
import { isAdded, isModified, isDeleted } from "./helper.js"
import { renderSizeImpactDescription, renderSizeImpactTable } from "./renderSizeImpact.js"
import { renderCacheImpactDescription, renderCacheImpactTable } from "./renderCacheImpact.js"

export const HEADER = `<!-- Generated by @jsenv/file-size-impact -->`

export const formatComment = ({
  sizeImpact,
  cacheImpact,
  trackingConfig,
  transformations,
  formatSize,
  maxLinesPerTable,
  pullRequestBase,
  pullRequestHead,
  baseSnapshot,
  afterMergeSnapshot,
}) => {
  const warnings = []
  const snapshotComparison = compareTwoSnapshots(baseSnapshot, afterMergeSnapshot)
  const groups = Object.keys(snapshotComparison)
  const groupCount = groups.length

  if (groupCount === 0) {
    warnings.push(
      `**Warning:** Nothing is tracked. It happens when tracking config is an empty object.`,
    )
  }

  // call formatSize only on numbers 'error' must be returned untouched
  const formatSizeOriginal = formatSize
  formatSize = (value, ...rest) => {
    if (typeof value === "number") return formatSizeOriginal(value, ...rest)
    return value
  }

  const head = `${HEADER}
<h4 id="file-size-impact">File size impact</h4>`
  const warning = renderWarnings(warnings)

  const parts = [
    warning,
    renderCommentBody({
      sizeImpact,
      cacheImpact,
      trackingConfig,
      transformations,
      formatSize,
      maxLinesPerTable,
      pullRequestBase,
      pullRequestHead,
      snapshotComparison,
    }),
  ].filter((string) => string.length > 0)

  return `${head}

${parts.join(`

`)}`
}

const renderWarnings = (warnings) => {
  if (warnings.length === 0) {
    return ""
  }

  return `---

${warnings.join(`

`)}

---`
}

const renderCommentBody = ({
  trackingConfig,
  transformations,
  formatSize,
  sizeImpact,
  cacheImpact,
  pullRequestBase,
  pullRequestHead,
  snapshotComparison,
  maxLinesPerTable,
}) => {
  const fileImpacts = {}
  const markFileImpact = (relativeUrl, groupName) => {
    if (!fileImpacts.hasOwnProperty(relativeUrl)) {
      fileImpacts[relativeUrl] = groupName
    }
  }

  const groupMessages = Object.keys(snapshotComparison).map((groupName) => {
    const groupComparison = snapshotComparison[groupName]
    const emptyGroup = Object.keys(groupComparison).length === 0
    if (emptyGroup) {
      return renderEmptyGroup(groupName, trackingConfig[groupName])
    }

    const sizeImpacts = {}
    const sizeImpactHidden = {}
    const cacheImpacts = {}
    const cacheImpactsHidden = {}

    const addImpact = (fileRelativeUrl, { event, sizeImpactMap, base, afterMerge }) => {
      const meta = event === "deleted" ? base.meta : afterMerge.meta
      const impact = { event, sizeImpactMap, base, afterMerge }
      const hookParameters = { fileRelativeUrl, ...impact }

      if (sizeImpact && hasSizeImpact(sizeImpactMap)) {
        if (metaEnables(meta, "showSizeImpact", hookParameters)) {
          markFileImpact(fileRelativeUrl, groupName)
          sizeImpacts[fileRelativeUrl] = impact
        } else {
          sizeImpactHidden[fileRelativeUrl] = impact
        }
      }

      if (cacheImpact && (event === "modified" || event === "added")) {
        if (metaEnables(meta, "showCacheImpact", hookParameters)) {
          markFileImpact(fileRelativeUrl, groupName)
          cacheImpacts[fileRelativeUrl] = impact
        } else {
          cacheImpactsHidden[fileRelativeUrl] = impact
        }
      }
    }

    Object.keys(groupComparison).forEach((fileRelativeUrl) => {
      const { base, afterMerge } = groupComparison[fileRelativeUrl]

      if (isAdded({ base, afterMerge })) {
        const event = "added"
        const sizeImpactMap = {}
        const sizeMapAfterMerge = afterMerge.sizeMap
        Object.keys(sizeMapAfterMerge).forEach((sizeName) => {
          sizeImpactMap[sizeName] = sizeMapAfterMerge[sizeName]
        })
        addImpact(fileRelativeUrl, {
          event,
          sizeImpactMap,
          base,
          afterMerge,
        })
        return
      }

      if (isDeleted({ base, afterMerge })) {
        const event = "deleted"
        const sizeImpactMap = {}
        const sizeMapOnBase = base.sizeMap
        Object.keys(sizeMapOnBase).forEach((sizeName) => {
          sizeImpactMap[sizeName] = -sizeMapOnBase[sizeName]
        })
        addImpact(fileRelativeUrl, {
          event,
          sizeImpactMap,
          base,
          afterMerge,
        })
        return
      }

      if (isModified({ base, afterMerge })) {
        const event = "modified"
        const sizeImpactMap = {}
        const sizeMapOnBase = base.sizeMap
        const sizeMapAfterMerge = afterMerge.sizeMap
        Object.keys(sizeMapAfterMerge).forEach((sizeName) => {
          sizeImpactMap[sizeName] = sizeMapAfterMerge[sizeName] - sizeMapOnBase[sizeName]
        })
        addImpact(fileRelativeUrl, {
          event,
          sizeImpactMap,
          base,
          afterMerge,
        })
      }
    })

    const allEmpty = [sizeImpacts, sizeImpactHidden, cacheImpacts, cacheImpactsHidden].every(
      (object) => Object.keys(object).length === 0,
    )
    if (allEmpty) {
      return `<details>
  <summary>${groupName} (0)</summary>
  <p>No impact on files in ${groupName} group.</p>
</details>`
    }

    const sizeImpactCount = Object.keys(sizeImpacts).length
    const cacheImpactCount = Object.keys(cacheImpacts).length
    const sizeImpactHiddenCount = Object.keys(sizeImpactHidden).length
    const cacheImpactHiddenCount = Object.keys(cacheImpactsHidden).length
    const elements = [
      ...(sizeImpactCount
        ? [
            renderSizeImpactDescription(sizeImpacts, groupName),
            renderSizeImpactTable(sizeImpacts, {
              transformations,
              formatSize,
              maxLinesPerTable,
            }),
          ]
        : []),
      ...(cacheImpactCount
        ? [
            renderCacheImpactDescription(cacheImpacts),
            renderCacheImpactTable(cacheImpacts, { transformations, formatSize, maxLinesPerTable }),
          ]
        : []),
      ...(sizeImpactHiddenCount > 0 || cacheImpactHiddenCount > 0
        ? [
            formulateHiddenImpacts({
              sizeImpactHidden,
              cacheImpactsHidden,
              transformations,
              formatSize,
              maxLinesPerTable,
            }),
          ]
        : []),
    ]

    const impactCount = countImpactedFiles(sizeImpacts, cacheImpacts)
    return `<details>
  <summary>${groupName} (${impactCount})</summary>
  ${elements.join(`
  `)}
</details>`
  })

  return `${formulateMergeImpact({ pullRequestHead, pullRequestBase, fileImpacts })}
  ${groupMessages.join(`

`)}`
}

const countImpactedFiles = (sizeImpacts, cacheImpacts) => {
  const files = []
  Object.keys(sizeImpacts).forEach((relativeUrl) => {
    if (!files.includes(relativeUrl)) {
      files.push(relativeUrl)
    }
  })
  Object.keys(cacheImpacts).forEach((relativeUrl) => {
    if (!files.includes(relativeUrl)) {
      files.push(relativeUrl)
    }
  })
  return files.length
}

const formulateMergeImpact = ({ pullRequestBase, pullRequestHead, fileImpacts }) => {
  const overallImpact = formulateOverallImpact(fileImpacts)
  return `<p>Merging ${pullRequestHead} into ${pullRequestBase} will ${overallImpact}.</p>`
}

const formulateOverallImpact = (fileImpacts) => {
  let impactedFileCount = 0
  let impactedGroupCount = 0
  const impactedGroups = []
  Object.keys(fileImpacts).forEach((relativeUrl) => {
    impactedFileCount++
    const groupName = fileImpacts[relativeUrl]
    if (!impactedGroups.includes(groupName)) {
      impactedGroups.push(groupName)
      impactedGroupCount++
    }
  })

  if (impactedFileCount === 0) {
    return `not impact files in any group.`
  }
  return `impact ${formulateFileQuantity(impactedFileCount)} in ${formulateGroupQuantity(
    impactedGroupCount,
  )}`
}

const formulateFileQuantity = (count) => {
  return count === 1 ? `1 file` : `${count} files`
}

const formulateGroupQuantity = (count) => {
  return count === 1 ? `1 grounp` : `${count} groups`
}

const hasSizeImpact = (sizeImpactMap) => {
  return Object.keys(sizeImpactMap).some((sizeName) => sizeImpactMap[sizeName] !== 0)
}

const formulateHiddenImpacts = ({
  sizeImpactsHidden,
  cacheImpactsHidden,
  transformations,
  formatSize,
}) => {
  const sizeImpactHiddenCount = Object.keys(sizeImpactsHidden).length
  const cacheImpactHiddenCount = Object.keys(cacheImpactsHidden).length
  const elements = [
    ...(sizeImpactHiddenCount
      ? [renderSizeImpactTable(sizeImpactsHidden, { transformations, formatSize })]
      : []),
    ...(cacheImpactHiddenCount
      ? [renderCacheImpactTable(cacheImpactsHidden, { transformations, formatSize })]
      : []),
  ]

  const hiddenImpactCount = countImpactedFiles(sizeImpactsHidden, cacheImpactsHidden)

  return `<details>
  <summary>Hidden (${hiddenImpactCount})</summary>
  <p>${formulateHiddenImpactMessage({ sizeImpactHiddenCount, cacheImpactHiddenCount })}.</p>
  ${elements.join(`
  `)}
  </details>`
}

const formulateHiddenImpactMessage = ({ sizeImpactHiddenCount, cacheImpactHiddenCount }) => {
  if (sizeImpactHiddenCount === 0) {
    if (cacheImpactHiddenCount === 1) {
      return `1 file cache impact has been hidden`
    }
    return `${sizeImpactHiddenCount} files cache impact have been hidden`
  }

  if (cacheImpactHiddenCount === 0) {
    if (sizeImpactHiddenCount === 1) {
      return `1 file size impact has been hidden`
    }
    return `${sizeImpactHiddenCount} files size impact have been hidden`
  }

  return `${formulateFileQuantity(sizeImpactHiddenCount)} size impact and ${formulateFileQuantity(
    cacheImpactHiddenCount,
  )} cache impact have been hidden`
}

const renderEmptyGroup = (groupName, groupConfig) => {
  return `<details>
  <summary>${groupName} (0)</summary>
  <p>No file in ${groupName} group (see config below).</p>

\`\`\`json
${JSON.stringify(groupConfig, null, "  ")}
\`\`\`

</details>`
}

const metaEnables = (
  meta,
  metaProperty,
  { fileRelativeUrl, event, sizeImpactMap, base, afterMerge },
) => {
  if (typeof meta === "boolean") {
    return meta
  }

  if (typeof meta === "object") {
    const metaPropertyValue = meta[metaProperty]
    if (typeof metaPropertyValue === "boolean") {
      return metaPropertyValue
    }

    if (typeof metaPropertyValue === "function") {
      return metaPropertyValue({
        fileRelativeUrl,
        event,
        sizeImpactMap,
        sizeMapOnBase: base.sizeMap,
        sizeMapAfterMerge: afterMerge.sizeMap,
      })
    }

    console.warn(`${metaProperty} must be a boolean or a function, received ${metaPropertyValue}`)
    return true
  }

  console.warn(`meta must be a boolean or a function, received ${meta}`)
  return Boolean(meta)
}
