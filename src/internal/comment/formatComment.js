import { compareTwoSnapshots } from "../compareTwoSnapshots.js"
import { isAdded, isModified, isDeleted } from "./helper.js"
import { renderFileSizeImpact } from "./renderFileSizeImpact.js"
import { renderCacheImpact } from "./renderCacheImpact.js"

export const HEADER = `<!-- Generated by @jsenv/file-size-impact -->`

export const formatComment = ({
  trackingConfig,
  transformations,
  formatSize,
  cacheImpact,
  pullRequestBase,
  pullRequestHead,
  baseSnapshot,
  afterMergeSnapshot,
}) => {
  const warnings = []
  const snapshotComparison = compareTwoSnapshots(baseSnapshot, afterMergeSnapshot)
  const groups = Object.keys(snapshotComparison)

  if (groups.length === 0) {
    warnings.push(
      `**Warning:** Nothing is tracked. It happens when tracking config is an empty object.`,
    )
  }

  // call formatSize only on numbers 'error' must be returned untouched
  const formatSizeOriginal = formatSize
  formatSize = (value, ...rest) => {
    if (typeof value === "number") return formatSizeOriginal(value, ...rest)
    return value
  }

  const parts = [
    renderWarnings(warnings),
    renderCommentBody({
      trackingConfig,
      transformations,
      formatSize,
      cacheImpact,
      pullRequestBase,
      pullRequestHead,
      snapshotComparison,
    }),
  ].filter((string) => string.length > 0)

  return `${HEADER}
<h4 id="file-size-impact">File size impact</h4>

${parts.join(`

`)}`
}

const renderWarnings = (warnings) => {
  if (warnings.length === 0) {
    return ""
  }

  return `---

${warnings.join(`

`)}

---`
}

const renderCommentBody = ({
  trackingConfig,
  transformations,
  formatSize,
  cacheImpact,
  pullRequestHead,
  pullRequestBase,
  snapshotComparison,
}) => {
  return renderEachGroup(
    (groupImpact, groupName) => {
      return renderGroup(groupImpact, {
        transformations,
        formatSize,
        cacheImpact,
        pullRequestHead,
        pullRequestBase,
        groupName,
      })
    },
    { snapshotComparison, trackingConfig },
  )
}

const renderEachGroup = (renderGroup, { snapshotComparison, trackingConfig }) => {
  const groupMessages = Object.keys(snapshotComparison).map((groupName) => {
    const groupComparison = snapshotComparison[groupName]
    const emptyGroup = Object.keys(groupComparison).length === 0
    if (emptyGroup) {
      return renderEmptyGroup(groupName, trackingConfig[groupName])
    }
    const { impactTracked, impactExcluded } = groupComparisonToFileByFileImpact(groupComparison)
    const impactTrackedCount = Object.keys(impactTracked).length
    const impactExcludedCount = Object.keys(impactExcluded).length
    if (impactTrackedCount === 0 && impactExcludedCount === 0) {
      return `<details>
  <summary>${groupName} (0)</summary>
  <p>No impact on files in ${groupName} group.</p>
</details>`
    }

    return `<details>
  <summary>${groupName} (${impactTrackedCount})</summary>
  ${renderGroup({ impactTracked, impactExcluded }, groupName)}
</details>`
  })

  return groupMessages.join(`

`)
}

const renderEmptyGroup = (groupName, groupConfig) => {
  return `<details>
  <summary>${groupName} (0)</summary>
  <p>No file in ${groupName} group (see config below).</p>

\`\`\`json
${JSON.stringify(groupConfig, null, "  ")}
\`\`\`

</details>`
}

const groupComparisonToFileByFileImpact = (groupComparison) => {
  const impactTracked = {}
  const impactExcluded = {}

  const addFileSizeImpact = (fileRelativeUrl, { event, sizeImpactMap, base, afterMerge }) => {
    const meta = event === "deleted" ? base.meta : afterMerge.meta
    if (
      metaEnableFileSizeImpact(meta, { fileRelativeUrl, event, sizeImpactMap, base, afterMerge })
    ) {
      impactTracked[fileRelativeUrl] = { event, sizeImpactMap, base, afterMerge }
    } else {
      impactExcluded[fileRelativeUrl] = { event, sizeImpactMap, base, afterMerge }
    }
  }

  Object.keys(groupComparison).forEach((fileRelativeUrl) => {
    const { base, afterMerge } = groupComparison[fileRelativeUrl]

    if (isAdded({ base, afterMerge })) {
      const event = "added"
      const sizeImpactMap = {}
      const sizeMapAfterMerge = afterMerge.sizeMap
      Object.keys(sizeMapAfterMerge).forEach((sizeName) => {
        sizeImpactMap[sizeName] = sizeMapAfterMerge[sizeName]
      })
      addFileSizeImpact(fileRelativeUrl, {
        event,
        sizeImpactMap,
        base,
        afterMerge,
      })
      return
    }

    if (isDeleted({ base, afterMerge })) {
      const event = "deleted"
      const sizeImpactMap = {}
      const sizeMapOnBase = base.sizeMap
      Object.keys(sizeMapOnBase).forEach((sizeName) => {
        sizeImpactMap[sizeName] = -sizeMapOnBase[sizeName]
      })
      addFileSizeImpact(fileRelativeUrl, {
        event,
        sizeImpactMap,
        base,
        afterMerge,
      })
      return
    }

    if (isModified({ base, afterMerge })) {
      const event = "modified"
      const sizeImpactMap = {}
      const sizeMapOnBase = base.sizeMap
      const sizeMapAfterMerge = afterMerge.sizeMap
      Object.keys(sizeMapAfterMerge).forEach((sizeName) => {
        sizeImpactMap[sizeName] = sizeMapAfterMerge[sizeName] - sizeMapOnBase[sizeName]
      })
      addFileSizeImpact(fileRelativeUrl, {
        event,
        sizeImpactMap,
        base,
        afterMerge,
      })
    }
  })

  return { impactTracked, impactExcluded }
}

const metaEnableFileSizeImpact = (
  meta,
  { fileRelativeUrl, event, sizeImpactMap, base, afterMerge },
) => {
  if (typeof meta === "boolean") {
    return meta
  }

  if (typeof meta === "object") {
    const { showFileSizeImpact } = meta
    if (typeof showFileSizeImpact === "boolean") {
      return showFileSizeImpact
    }

    if (typeof showFileSizeImpact === "function") {
      return meta.showFileSizeImpact({
        fileRelativeUrl,
        event,
        sizeImpactMap,
        sizeMapOnBase: base.sizeMap,
        sizeMapAfterMerge: afterMerge.sizeMap,
      })
    }

    console.warn(
      `showFileSizeImpact must be a boolean or a function, received ${showFileSizeImpact}`,
    )
    return true
  }

  // it happens only for unit test and I am lazy to rewrite them to explicitely pass
  if (typeof meta === undefined) {
    return true
  }

  console.warn(`meta must be a boolean or a function, received ${meta}`)
  return Boolean(meta)
}

const renderGroup = (
  groupImpact,
  { transformations, formatSize, cacheImpact, pullRequestHead, pullRequestBase, groupName },
) => {
  const parts = [
    renderFileSizeImpact(groupImpact, {
      transformations,
      formatSize,
      pullRequestHead,
      pullRequestBase,
      groupName,
    }),
    ...(cacheImpact
      ? [renderCacheImpact(groupImpact, { transformations, formatSize, groupName })]
      : []),
  ]

  return parts.join(`
  `)
}
