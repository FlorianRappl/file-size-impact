import { compareTwoSnapshots } from "../compareTwoSnapshots.js"
import { isAdded, isModified, isDeleted } from "./helper.js"
import { renderFileSizeImpact } from "./renderFileSizeImpact.js"
import { renderCacheImpact } from "./renderCacheImpact.js"

export const HEADER = `<!-- Generated by @jsenv/file-size-impact -->`

export const formatComment = ({
  trackingConfig,
  transformations,
  formatSize,
  cacheImpact,
  pullRequestBase,
  pullRequestHead,
  baseSnapshot,
  afterMergeSnapshot,
}) => {
  const warnings = []
  const snapshotComparison = compareTwoSnapshots(baseSnapshot, afterMergeSnapshot)
  const groups = Object.keys(snapshotComparison)

  if (groups.length === 0) {
    warnings.push(
      `**Warning:** Nothing is tracked. It happens when tracking config is an empty object.`,
    )
  }

  // call formatSize only on numbers 'error' must be returned untouched
  const formatSizeOriginal = formatSize
  formatSize = (value, ...rest) => {
    if (typeof value === "number") return formatSizeOriginal(value, ...rest)
    return value
  }

  const parts = [
    renderWarnings(warnings),
    renderCommentBody({
      trackingConfig,
      transformations,
      formatSize,
      cacheImpact,
      pullRequestBase,
      pullRequestHead,
      snapshotComparison,
    }),
  ].filter((string) => string.length > 0)

  return `${HEADER}
<h4 id="file-size-impact">File size impact</h4>

${parts.join(`

`)}`
}

const renderWarnings = (warnings) => {
  if (warnings.length === 0) {
    return ""
  }

  return `---

${warnings.join(`

`)}

---`
}

const renderCommentBody = ({
  trackingConfig,
  transformations,
  formatSize,
  cacheImpact,
  pullRequestHead,
  pullRequestBase,
  snapshotComparison,
}) => {
  return renderEachGroup(
    (groupImpact, groupName) => {
      return renderGroup(groupImpact, {
        transformations,
        formatSize,
        cacheImpact,
        pullRequestHead,
        pullRequestBase,
        groupName,
      })
    },
    { snapshotComparison, trackingConfig },
  )
}

const renderEachGroup = (renderGroup, { snapshotComparison, trackingConfig }) => {
  const groupMessages = Object.keys(snapshotComparison).map((groupName) => {
    const groupComparison = snapshotComparison[groupName]
    const emptyGroup = Object.keys(groupComparison).length === 0
    if (emptyGroup) {
      return renderEmptyGroup(groupName, trackingConfig[groupName])
    }
    const impactOnGroup = groupComparisonToFileByFileImpact(groupComparison)
    const impactCount = Object.keys(impactOnGroup).length
    const noImpact = impactCount === 0
    if (noImpact) {
      return `<details>
  <summary>${groupName} (0)</summary>
  <p>No impact on files in ${groupName} group.</p>
</details>`
    }

    return `<details>
  <summary>${groupName} (${impactCount})</summary>
  ${renderGroup(impactOnGroup, groupName)}
</details>`
  })

  return groupMessages.join(`

`)
}

const renderEmptyGroup = (groupName, groupConfig) => {
  return `<details>
  <summary>${groupName} (0)</summary>
  <p>No file in ${groupName} group (see config below).</p>

\`\`\`json
${JSON.stringify(groupConfig, null, "  ")}
\`\`\`

</details>`
}

const groupComparisonToFileByFileImpact = (groupComparison) => {
  const fileByFileImpact = {}
  Object.keys(groupComparison).forEach((fileRelativeUrl) => {
    const { base, afterMerge } = groupComparison[fileRelativeUrl]

    if (isAdded({ base, afterMerge })) {
      fileByFileImpact[fileRelativeUrl] = {
        base,
        afterMerge,
        event: "added",
      }
      return
    }

    if (isDeleted({ base, afterMerge })) {
      fileByFileImpact[fileRelativeUrl] = {
        base,
        afterMerge,
        event: "deleted",
      }
      return
    }

    if (isModified({ base, afterMerge })) {
      fileByFileImpact[fileRelativeUrl] = {
        base,
        afterMerge,
        event: "modified",
      }
    }
  })
  return fileByFileImpact
}

const renderGroup = (
  groupImpact,
  { transformations, formatSize, cacheImpact, pullRequestHead, pullRequestBase, groupName },
) => {
  const parts = [
    renderFileSizeImpact(groupImpact, {
      transformations,
      formatSize,
      pullRequestHead,
      pullRequestBase,
      groupName,
    }),
    ...(cacheImpact
      ? [renderCacheImpact(groupImpact, { transformations, formatSize, groupName })]
      : []),
  ]

  return parts.join(`
  `)
}
